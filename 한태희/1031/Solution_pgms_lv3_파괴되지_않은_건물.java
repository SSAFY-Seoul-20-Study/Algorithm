import java.util.*;

/*
# 파괴되지 않은 건물
SSAFY에서 배운 알고리즘은 정말 새발의 피라는 것을 깨닫게 해주는 문제

일단 그래도 시간 복잡도를 엄밀하게 따지는 실력은 증가해서, 입력 배열 크기를 딱 보고 막 탐색으로 구현하면 백퍼센트 시간 초과 나는 문제라는 것을 인지는 했음.

하지만, 3시간 동안 고민을 해봐도 문제를 어떻게 풀어야할지 떠올리지 못함. 생각하길 1시간 즈음에 '아 이건 내가 자주 사용하던 방법들로는 풀 수가 없는 문제다'라는 것을 깨닫고 창의적인 방법들을 떠올리길 노력해보았지만 결국 실패..

결국 인터넷 답 참고

핵심 아이디어는 '구간합'

사각형 모양의 변경 정보는 그 배열 속 요소를 하나씩 일일히 수정해줄 필요 없이, 원본 배열과 별개의 구간합 배열에 4방향 꼭지점에만 값을 입력하는 방식으로 정보를 저장할 수 있음.

예시)
```
0  0  0  0  0  0  0  0          0  0  0  0  0  0  0  0 
0  5  5  5  5  5  0  0          0  5  0  0  0  0 -5  0                  
0  5  5  5  5  5  0  0          0  0  0  0  0  0  0  0
0  5  5  5  5  5  0  0    ->    0  0  0  0  0  0  0  0
0  5  5 -2 -2 -2 -7  0          0  0  0 -7  0  0  0  7
0  5  5 -2 -2 -2 -7  0          0  0  0  0  0  0  0  0
0  0  0 -7 -7 -7 -7  0          0 -5  0  0  0  0  5  0
0  0  0  0  0  0  0  0          0  0  0  7  0  0  0 -7
```

구간합 배열에서 가로방향 구간합 다음 세로방향 구간합을 진행하면 원본 데이터를 구할 수 있음을 알 수 있음.

이때 주의해야 하는 사항은
1) 구간합 배열은 사각형 배열이 똑같은 값으로 차있는 경우만 복원 가능하므로, 초기 상태로 주어진 건물 상태는 별개로 저장되어야함.
2) 구간합 배열은 N+1, M+1 크기로 사용되어야함
 */

class Solution {
    public int solution(int[][] board, int[][] skill) {
        int N = board.length;
        int M = board[0].length;

        int[][] a = new int[N + 1][M + 1];

        for (int[] sk : skill) {
            int type = sk[0];
            int r1 = sk[1];
            int c1 = sk[2];
            int r2 = sk[3];
            int c2 = sk[4];
            int degree = sk[5];

            if (type == 1) {
                degree = -degree;
            }

            a[r1][c1] += degree;
            a[r1][c2 + 1] += -degree;
            a[r2 + 1][c1] += -degree;
            a[r2 + 1][c2 + 1] += degree;
        }

        for (int i = 0; i < N + 1; i++) {
            for (int j = 1; j < M + 1; j++) {
                a[i][j] += a[i][j - 1];
            }
        }

        for (int j = 0; j < M + 1; j++) {
            for (int i = 1; i < N + 1; i++) {
                a[i][j] += a[i - 1][j];
            }
        }

        int answer = 0;

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                int n = board[i][j] + a[i][j];
                if (n > 0) {
                    answer++;
                }
            }
        }

        return answer;
    }
}